---
title: Spring容器和SpringMVC容器
tags:
- spring
- springmvc
categories: Programming
---

Spring Framework本身没有Web功能，Spring MVC使用WebApplicationContext类扩展ApplicationContext，使得拥有web功能。Spring容器与SpringMVC容器是父子关系，子容器可以访问父容器的对象，父容器不能访问子容器的类，如果我们在springMVC配置文件中，直接扫描所有类，把service、dao、controller都交给SpringMVC去管理是可以的，但是假如用spring去管理Contoller，它是访问不到这个类的，因为contoller是在springMVC容器中,假如在Spring配置直接扫描所有类包括controller，而不配置springMVC的话，这样服务器发来的请求，将会出现404的问题，因为它找不到controller，spring无法注入Controller。原则上我们是可以把service、dao和controller都交给springMVC去管理，直接在SpringMVC配置文件中让它扫所有包就可以，但是出于未来扩展的考虑，spring和springMVC分开配置，由 spring 去管理service，有利于以后扩展，即便以后加多个struct2也不用影响原有配置。首先，对于一个web应用，其部署在web容器中，web容器提供其一个全局的上下文环境，这个上下文就是ServletContext，其为后面的spring IoC容器提供宿主环境；其次，在web.xml中会提供有contextLoaderListener。在web容器启动时，会触发容器初始化事件，此时contextLoaderListener会监听到这个事件，其contextInitialized方法会被调用，在这个方法中，spring会初始化一个启动上下文，这个上下文被称为根上下文，即WebApplicationContext，这是一个接口类，确切的说，其实际的实现类是XmlWebApplicationContext。这个就是spring的IoC容器，其对应的Bean定义的配置由web.xml中的context-param标签指定。在这个IoC容器初始化完毕后，spring以WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE为属性Key，将其存储到ServletContext中，便于获取；再次，contextLoaderListener监听器初始化完毕后，开始初始化web.xml中配置的Servlet，这个servlet可以配置多个，以最常见的DispatcherServlet为例，这个servlet实际上是一个标准的前端控制器，用以转发、匹配、处理每个servlet请求。DispatcherServlet上下文在初始化的时候会建立自己的IoC上下文，用以持有spring mvc相关的bean。在建立DispatcherServlet自己的IoC上下文时，会利用WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE先从ServletContext中获取之前的根上下文(即WebApplicationContext)作为自己上下文的parent上下文。有了这个parent上下文之后，再初始化自己持有的上下文。这个DispatcherServlet初始化自己上下文的工作在其initStrategies方法中可以看到，大概的工作就是初始化处理器映射、视图解析等。这个servlet自己持有的上下文默认实现类也是mlWebApplicationContext。初始化完毕后，spring以与servlet的名字相关(此处不是简单的以servlet名为Key，而是通过一些转换，具体可自行查看源码)的属性为属性Key，也将其存到ServletContext中，以便后续使用。这样每个servlet就持有自己的上下文，即拥有自己独立的bean空间，同时各个servlet共享相同的bean，即根上下文(第2步中初始化的上下文)定义的那些bean。在上面的web.xml中，我们看到基于ContextLoaderListener和DispatcherServlet都可以配置spring相关的XML，两类XML的前缀分别以spring和springmvc开头，说明，基于ContextLoaderListener加载的XML配置，原则上是与spring容器相关的(也可以说是父容器)；而基于DispatcherServlet加载的XML配置，原则上是与springmvc容器相关的(相当于子容器)。父容器加载的配置文件默认地址为：/WEB-INF/applicationContext.xml，它默认以applicationContext命名，说明它是spring的全局的配置，如果你项目中此文件名和地址都没有改，那么在web.xml中可以不用配置，spring容器会自动到默认地址下去加载。子容器的配置文件命名默认为[servlet-name]-servlet.xml方式，也就是说servlet-name中如果没有指定init-param属性，系统自动寻找的配置文件为[servlet-name]-servlet.xml，默认路径也是WEB-INF下。所以个人建议，基于mvc相关的spring配置由DispatcherServlet加载，而其余的JavaBean都交给ContextLoaderListener加载。值得说明的是这两种方式加载spring的ApplicationContext上下文对象不是合并存储的。mvc context可以引用applicationContext的bean，而applicationContext无法引用到mvc的bean，spring查找bean，会先在当前context中查找，如果没有满足的，再到父容器查找。而且两个context中可以存在相同的bean定义的，只不过优先查找当前context。并且各context上下文中的声明式标签相互不起作用。也就是说，如果你在applicationContext.xml中声明的 ，在mvc的context中是不起作用的。说了这么多，其实我项目中的错误原因也就找到了，我的问题在于，我将声明在了application上下文的配置中，从而导致mvc的context 中声明的 不起作用，项目也就无法识别和加载controller了，所以会出现需要controller处理的http请求，最后都是莫名其妙的404错误。

